'use strict';
/**
 * `list` type prompt
 */

const chalk = require('chalk');
const figures = require('figures');
const CheckboxPrompt = require('./checkbox');

class RadioPrompt extends CheckboxPrompt {

  constructor(questions, rl, answers) {
    super(questions, rl, answers);
    this.choices = {};
  }

  _run(cb) {
    super._run(cb);
  }

  onSpaceKey() {
    this.clearAllChoices();
    this.setChoice(this.pointer);
    this.render();
  }

  onInverseKey() {
    this.clearAllChoices();
    this.render();
  }

  onAllKey() {
    this.opt.choices.choices.forEach((value) => {console.log(value)})
  }

  onNumberKey(input) {
    this.updateChoices('nuevo', input.toString());
  }

  clearChoice(index) {
    const item = this.opt.choices.getChoice(index);
    if (item !== undefined) {
      item.checked = false;
      for (let key in this.choices) {
        let data = this.choices[key]
        if(data.value == item.value) {
          data.checked = false;
        }
      }
    }
  }

  clearAllChoices() {
    this.opt.choices.forEach((choice) => {
      if (choice.type !== 'separator') {
        choice.checked = false;
      }
    });
    for (let key in this.choices) {
      let data = this.choices[key]
      data.checked = item.checked;
    }
  }

  setChoice(index) {
    const item = this.opt.choices.getChoice(index);
    if (item !== undefined) {
      item.checked = true;
      for (let key in this.choices) {
        let data = this.choices[key]
        if(data.value == item.value) {
          data.checked = true;
        }
      }
    }
  }

  toggleChoice(index) {
    const item = this.opt.choices.getChoice(index);
    if (item !== undefined) {
      item.checked = !item.checked;
      for (let key in this.choices) {
        let data = this.choices[key]
        if(data.value == item.value) {
          data.checked = item.checked;
        }
      }
    }
  }

  updateChoices(key, value) {
    this.opt.choices.choices.length = 0; // Clear choices array
    this.opt.choices.realChoices.length = 0; // Clear realChoices array
    if(this.choices[key]) {
      this.choices[key].value = value;
    } else {
      this.choices[key] = {value: value, checked: false};
    }
    for (let key in this.choices) {
      let data = this.choices[key];
      let value = data.value;
      let checked = data.checked;
      let choice = `${key}: ${value}`;
      this.opt.choices.push(choice);
      if(checked) {
        let idx = this.opt.choices.choices.indexOf(choice);
        this.setChoice(idx);
      }
    };
    this.render();
  }

  render(...args ) {
    // Render question
    let message = this.getQuestion();
    let bottomContent = '';

    if (!this.dontShowHints) {
      message +=
        '(Press ' +
        chalk.cyan.bold('<space>') +
        ' to select, ' +
        chalk.cyan.bold('<i>') +
        ' to unselect, and ' +
        chalk.cyan.bold('<enter>') +
        ' to proceed)';
    }

    // Render choices or answer depending on the state
    if (this.status === 'answered') {
      message += chalk.cyan(this.selection.join(', '));
    } else {
      const choicesStr = renderChoices(this.opt.choices, this.pointer);
      const indexPosition = this.opt.choices.indexOf(
        this.opt.choices.getChoice(this.pointer)
      );
      const realIndexPosition =
        this.opt.choices.reduce((acc, value, i) => {
          // Dont count lines past the choice we are looking at
          if (i > indexPosition) {
            return acc;
          }
          // Add line if it's a separator
          if (value.type === 'separator') {
            return acc + 1;
          }

          let l = value.name;
          // Non-strings take up one line
          if (typeof l !== 'string') {
            return acc + 1;
          }

          // Calculate lines taken up by string
          l = l.split('\n');
          return acc + l.length;
        }, 0) - 1;
      message +=
        '\n' + this.paginator.paginate(choicesStr, realIndexPosition, this.opt.pageSize);
    }

    if (args && args[0]) {
      bottomContent = chalk.red('>> ') + args[0];
    }

    this.screen.render(message, bottomContent);
  }
}

/**
 * Function for rendering checkbox choices
 * @param  {Number} pointer Position of the pointer
 * @return {String}         Rendered content
 */

function renderChoices(choices, pointer) {
  let output = '';
  let separatorOffset = 0;

  choices.forEach((choice, i) => {
    if (choice.type === 'separator') {
      separatorOffset++;
      output += ' ' + choice + '\n';
      return;
    }

    if (choice.disabled) {
      separatorOffset++;
      output += ' - ' + choice.name;
      output += ` (${
        typeof choice.disabled === 'string' ? choice.disabled : 'Disabled'
      })`;
    } else {
      const line = getCheckbox(choice.checked) + ' ' + choice.name;
      if (i - separatorOffset === pointer) {
        output += chalk.cyan(figures.pointer + line);
      } else {
        output += ' ' + line;
      }
    }

    output += '\n';
  });

  return output.replace(/\n$/, '');
}

/**
 * Get the checkbox
 * @param  {Boolean} checked - add a X or not to the checkbox
 * @return {String} Composited checkbox string
 */

function getCheckbox(checked) {
  return checked ? chalk.green(figures.radioOn) : figures.radioOff;
}

module.exports = RadioPrompt;
